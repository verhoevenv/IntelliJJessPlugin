{
    parserClass="com.github.verhoevenv.intellij.jess.parser.JessParser"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Jess"
    psiImplClassSuffix="Impl"
    psiPackage="com.github.verhoevenv.intellij.jess.psi"
    psiImplPackage="com.github.verhoevenv.intellij.jess.psi.impl"

    elementTypeHolderClass="com.github.verhoevenv.intellij.jess.psi.JessTypes"
    elementTypeClass="com.github.verhoevenv.intellij.jess.psi.JessElementType"
    tokenTypeClass="com.github.verhoevenv.intellij.jess.psi.JessTokenType"

  tokens=[
    COMMENT = "regexp:;[^\r\n]*"
    SYMBOL = "regexp:[a-zA-Z$*=+/<>_?#.-][a-zA-Z0-9$*=+/<>_?#.-]*"
    STRING_LITERAL = "regexp:(\"([^\"\\]|\\.)*\")"
    NUMBER_LITERAL='regexp:\d+(\.\d*)?'
    TRUE = "TRUE"
    FALSE = "FALSE"
    NIL = "nil"
    LP = "("
    RP = ")"
    DEFRULE = "defrule"
    DEFMODULE = "defmodule"
    DEFTEMPLATE = "deftemplate"
    DEFFACTS = "deffacts"
    DEFCLASS = "defclass"
    DEFFUNCTION = "deffunction"
    IMPORT = "import"
    SLOT = "slot"
    DECLARE = "declare"
    ARROW = "=>"
    AMP = "&"
    PIPE = "|"
    COLON = ":"
  ]

}

jessFile ::= form*
form ::= (rule|construct|resolvable|COMMENT)
rule ::= LP DEFRULE rulehead ARROW rulebody RP

rulehead ::= rulename ruleconditional*
rulename ::= modulequalification? nonqualifiedrulename
ruleconditional ::= rulepattern
rulepattern ::= LP factname ruleslot* RP
ruleslot ::= LP slotname valuetest RP

valuetest ::= extendedsymbolicparenmatched*

extendedsymbolicparenmatched ::= ((LP extendedsymbolicparenmatched RP)|multiplesymbols)
multiplesymbols ::= extendedsymbolic+
extendedsymbolic ::= (SYMBOL|AMP|COLON|PIPE|literal|resolvable)
/*
valuetest ::= (nonrecursivevaluetest|andconstraint|orconstraint)
nonrecursivevaluetest ::= (literal|variable|predicateconstraint)
predicateconstraint ::= COLON function
andconstraint ::= nonrecursivevaluetest AMP valuetest
orconstraint ::= nonrecursivevaluetest PIPE valuetest
*/

rulebody ::= ruleaction*
ruleaction ::= resolvable

construct ::= (moduleconstruct|templateconstruct|factsconstruct|classconstruct|functionconstruct)

moduleconstruct ::= LP DEFMODULE jesssymbol+ RP

templateconstruct ::= LP DEFTEMPLATE templatename templatedeclarelist? templateslot* RP
templatename ::= modulequalification? factname
templatedeclarelist ::= LP DECLARE templatedeclaration* RP
templatedeclaration ::= LP (jesssymbol|booleanliteral)+ RP
templateslot ::= LP SLOT slotname RP
slotname ::= jesssymbol

factsconstruct ::= LP DEFFACTS factdbname fact* RP
factdbname ::= jesssymbol
fact ::= LP factname factslot* RP
factslot ::= LP slotname literal RP

classconstruct ::= LP DEFCLASS jesssymbol+ RP

functionconstruct ::= LP DEFFUNCTION functionname functionargumentlist resolvable* RP
functionargumentlist ::= LP variable* RP

modulequalification ::= modulename moduleseperator
modulename ::= jesssymbol
nonqualifiedrulename ::= jesssymbol

booleanliteral ::= (TRUE | FALSE)
literal ::= STRING_LITERAL | booleanliteral | NUMBER_LITERAL | NIL
variable ::= jesssymbol
factname ::= jesssymbol

private jesssymbol ::= SYMBOL
moduleseperator ::= COLON COLON
resolvable ::= functioncall | methodcall | (LP resolvable RP)
methodcall ::= LP resolvable functionargument* RP
functioncall ::= LP functionname functionargument* RP
functionname ::= jesssymbol
functionargument ::= (literal|variable|resolvable)